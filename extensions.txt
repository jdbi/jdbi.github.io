== The Extension Framework

The Jdbi core code provides a rich, programmatic interface for
database operations. It is possible to extend this core by writing
extensions that plug into the Jdbi core framework and provide new
functionality.

Jdbi ships with the SQLObject plugin, which offers declarative use of Jdbi
by placing annotations on interface methods.

The Extension framework functionality is generic and supports any type of
extension that can be registered with the Jdbi core.


=== Using Jdbi extensions

Using an extension type with Jdbi is straightforward. The link:{jdbidocs}/core/Jdbi.html[Jdbi^] class offers
the link:{jdbidocs}/core/Jdbi.html#withExtension(java.lang.Class,org.jdbi.v3.core.extension.ExtensionCallback)[Jdbi#withExtension^] and link:{jdbidocs}/core/Jdbi.html#useExtension(java.lang.Class,org.jdbi.v3.core.extension.ExtensionConsumer)[Jdbi#useExtension^] methods to execute extension code.

Alternatively, an on-demand extension can be created with the link:{jdbidocs}/core/Jdbi.html#onDemand(java.lang.Class)[Jdbi#onDemand^].

[source,java,indent=0]
----
include::{exampledir}/ExtensionFrameworkTest.java[tags=dao]
----

This is an extension type for the SQLObject extension. The SQLObject extension uses annotations to
identify functionality, however this is implementation specific. If any of the SQLObject annotations (link:{jdbidocs}/sqlobject/statement/SqlBatch.html[@SqlBatch^],
link:{jdbidocs}/sqlobject/statement/SqlCall.html[@SqlCall^],
link:{jdbidocs}/sqlobject/statement/SqlQuery.html[@SqlQuery^],
link:{jdbidocs}/sqlobject/statement/SqlScript.html[@SqlScript^] and
link:{jdbidocs}/sqlobject/statement/SqlUpdate.html[@SqlUpdate^]) is present on either the type or any method, the SQLObject extension will be used.


Now the link:{jdbidocs}/core/Jdbi.html#withExtension(java.lang.Class,org.jdbi.v3.core.extension.ExtensionCallback)[Jdbi#withExtension^] and link:{jdbidocs}/core/Jdbi.html#useExtension(java.lang.Class,org.jdbi.v3.core.extension.ExtensionConsumer)[Jdbi#useExtension^] methods are used to access SQLObject functionality:

[source,java,indent=0]
----
include::{exampledir}/ExtensionFrameworkTest.java[tags=use]

include::{exampledir}/ExtensionFrameworkTest.java[tags=with]
----


=== How an extension works

An extension type is an interface class. It contains some information
that allows the extension framework to determine that the interface
represents an extension.

When calling one of the Jdbi methods (link:{jdbidocs}/core/Jdbi.html#withExtension(java.lang.Class,org.jdbi.v3.core.extension.ExtensionCallback)[Jdbi#withExtension^],
link:{jdbidocs}/core/Jdbi.html#useExtension(java.lang.Class,org.jdbi.v3.core.extension.ExtensionConsumer)[Jdbi#useExtension^]
and link:{jdbidocs}/core/Jdbi.html#onDemand(java.lang.Class)[Jdbi#onDemand^]
with the extension as a parameter, they return an implementation of the extension.

When useExtension or withExtension are called, the ExtensionFactory which handles
an extension is retrieved from the Extensions configuration object.
ExtensionFactories must be registered ahead of time with the Jdbi
core using the Extensions#register(ExtensionFactory) method.

The extension factory then creates an ExtensionMetadata object that
contains information about each method on the extension type:

- The ExtensionHandler to invoke for each method
- All ExtensionHandlerCustomizers that change the behavior of the ExtensionHandler
- The ConfigCustomizer instance to apply when the ExtensionHandler is invoked

Metadata exists per extension type and is created only once and then reused.


Jdbi usually returns a Java proxy object to user code which in turn
executes the extension handlers. This proxy object contains an
instance of ExtensionHandlerInvoker for each method on the extension
type which is invoked. It manages the objects specific to the
invocation (Handle, config) and then executes the ExtensionHandler.

[ditaa, round-corners=true, transparent=false]
----

User code --> [register ExtensionFactory with Jdbi] --> Extensions Config object
   |
   |
   | ---> [calls Jdbi.use/withExtension] ---> ExtensionFactory
   |                                                 |             +-------------------+             +------------------+
   |                                                 +---> creates | ExtensionMetadata | --> defines | ExtensionHandler |
   |                                                 |             +-------------------+             +------------------+
   |                                                 |                                                       ^
   |                                                 |                                                       |
   |                                                 |                                                       | matches
   |                                                 |                                                       |
   |                                                 |                                                       |
   |                                                 |             +-------------------+              +-------------------------+
   |                                                 +---> creates | Java proxy object | --> contains | ExtensionHandlerInvoker |
   | <------- [return to user code] <----------------------------- +-------------------+              +-------------------------+
   |
   |                                        +-------------------+              +-------------------------+
   | --> [invoke extension type method] --> | Java proxy object | --> executes | ExtensionHandlerInvoker |
   |                                        +-------------------+              +-------------------------+
   |                                                                                       |
   |                                                                                       | invokes with Handle
   |                                                                                       | and Configuration
   |                                                                                       v
   |                                                                            +------------------+
   | <---- [ return result to user code] <------------------------------------- | ExtensionHandler |
                                                                                +------------------+

----



The implementation is provided by an ExtensionFactory. ExtensionFactories are registered ahead of time with the Jdbi core using the Extensions#register(ExtensionFactory) method.

Whenever the implementation for an extension type is needed, the matching ExtensionFactory is retrieved and an instance implementing the extension type is created.






Each method in the extension type is represented by an ExtensionHandler instance. An extension handler is created by an ExtensionHandlerFactory. Jdbi provides a number of default factories and each ExtensionFactory can contribute extension specific extension handler factories.

This proxy contains an ExtensionHandlerInvoker for each method in the extension type. When a method is called from user user, it will execute the ExtensionHandlerInvoker, which in turn invokes the ExtensionHandler.





=== On-demand extension code

=== Main concepts

==== Extensions configuration object

Registry for extension factories and global extension objects (ExtensionHandlerFactory, ExtensionHandlerCustomizer and ConfigCustomizerFactory).


==== ExtensionFactory


Every extension registers a factory, when accepting a specific extension type provides
extension specific objects in addition to the global extension objects. Also participates in metadata creation.


===== Non-virtual factories

===== Using abstract classes as extensions

==== ExtensionHandler and ExtensionHandlerFactory

==== ExtensionHandlerInvoker

==== ExtensionMetadata

===== Global default factories

==== ExtensionHandlerCustomizer

==== ConfigCustomizerFactory

==== ExtensionContext

==== ExtensionConfigurer

=== Annotations

==== UseExtensionHandler

==== UseExtensionConfigurer

==== UseExtensionCustomizer

===== ExtensionCustomizationOrder

=== Code example



Rewrite of the core extension framework (#2285)

    * Rewrite of the core extension framework

    The current extension framework is relatively simple. It supports
    attaching an extension interface which looks up a factory that then
    has the responsibility of either looking up an implementation class or
    create a proxy to execute code for each method.

    Due to that simple structure, there are a number of inconsistencies,
    especially around the extension context and wrapping each method from
    an interface.

    The main reason for this is that most of the interesting functionality
    for the extension code is not actually in the core/extension package
    but in sqlobject. Extension is little more than just a scaffold that
    was designed with sqlobject in mind.

    There is nothing wrong with this. However, it is possible to move a
    lot of the "interesting" functionality from the sqlobject code into
    the core package without losing backwards compatibility and then
    making it possible to implement additional functionality using
    extensions.

    SQL Objects uses three concepts:

    * Handlers. These are code pieces that are executed when an extension
      method is called. This is the code for SQLUpdate, SQLQuery etc.
    * HandlerDecorators. These code pieces change the behavior of a
      handler. Transactions are implemented as a decorator.
    * Configurers. These code pieces add or change the configuration for a
      method before it is called. This configuration is then spliced into
      the Handle through the ExtensionContext so that all code that runs
      within the Handler method uses that modified
      configuration. Configurers are used for the "Use..." annotations.

    None of these concepts is SQLObject specific. This is generic code
    that can be used for any extension. But by being split out of the core
    and part of the sqlobject module, it is not available to any other
    extension or has to be copied and pasted.

    While the change looks big, it is mostly moving existing code around
    and cleaning it up. It introduces three new concepts to the core:

    `ExtensionHandler` - This is equivalent to the SqlObject Handler
    class.

    `ExtensionHandler.Factory` - SqlObject HandlerFactory, but with the
    `accepts / build` pattern.

    `@UseExtensionHandler` annotation - equivalent to `@SqlOperation`. It
    also provides an `id` attribute to allow multiple extensions to
    differentiate between `@UseExtensionHandler` instances intended for
    them or for another extension.

    `ExtensionHandlerCustomizer` - This is the equivalent of the SqlObject
    `HandleDecorator`

    `@UseExtensionCustomizer` - This is the equivalent of the SqlObject
    `@SqlMethodDecoratingAnnotation` annotation.

    `@ExtensionCustomizationOrder` - This is the equivalent of the
    SqlObject `@DecoratorOrder` annotation.

    `ExtensionConfigurer` - This is the equivalent of SqlObject
    `Configurer`. Literally.

    `ConfigCustomizer` - This is an explicit interface where the SqlObject
    code uses `Consumer<ConfigRegistry>`. We are not consuming the
    registry, but customizing it. Makes code more readable.

    `ConfigCustomizerFactory` - A factory class that creates a collection
    of `ConfigCustomizer` elements for an extension type or an extension
    type method. That concept existed sprawled out in the
    `SqlObjectInitData` class but was not pluggable and hardcoded to the
    `Configurer` interface.

    `@UseExtensionCustomizer` - This is the equivalent of the SqlObject
    `@ConfiguringAnnotation`

    `ExtensionFactory` gets a lot of new things, all of them with defaults
    that match the current code.
    * a set of flags to control extension factory behavior
    * bunch of getters for custom ExtensionHandlerFactories,
      ExtensionHandlerCustomizers and ExtensionConfigurerFactories

    The `Extensions` configuration gets some new things:
    * methods to register ExtensionHandlerFactories,
      ExtensionHandlerCustomizers and ExtensionConfigurerFactories
      globally
    * a method to retrieve metadata for a given extension type

    `ExtensionHandlerInvoker` takes the role of `InContextInvoker`. All
    invokers are managed by the `ExtensionMetadata` class

    `ExtensionMetadata` takes the role of `SqlObjectInitData`. It contains
    all of the discovered functionality from an extension type. It builds
    a map of `ExtensionHandler` objects that can be wrapped into an
    `ExtensionInvoker` with all customizers and configurers added. Those
    `ExtensionInvoker` classes are called through the Proxy when a method
    is invoked.

    `ExtensionFactoryDelegate` wraps the functionality of the old
    SqlObjectFactory code. It may simply delegate to the actual factory
    generated object or create the map of ExtensionHandlers with
    corresponding ExtensionHandlerInvokers and wrap them into a proxy
    object.

    Similar to the SqlObject code, a number of "glue"
    `ExtensionHandlerFactory` instances are used to create method handlers
    that are not managed by the extension specific code:

    * bridge methods
    * interface default methods
    * direct method invocations if the factory provides an actual object to attach to
